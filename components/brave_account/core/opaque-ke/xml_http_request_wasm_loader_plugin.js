// class FileListPlugin {
//     static defaultOptions = {
//       outputFile: 'assets.md',
//     };
  
//     // Any options should be passed in the constructor of your plugin,
//     // (this is a public API of your plugin).
//     constructor(options = {}) {
//       // Applying user-specified options over the default options
//       // and making merged options further available to the plugin methods.
//       // You should probably validate all the options here as well.
//       this.options = { ...FileListPlugin.defaultOptions, ...options };
//     }
  
//     apply(compiler) {
//       const pluginName = FileListPlugin.name;
  
//       // webpack module instance can be accessed from the compiler object,
//       // this ensures that correct version of the module is used
//       // (do not require/import the webpack or any symbols from it directly).
//       const { webpack } = compiler;
  
//       // Compilation object gives us reference to some useful constants.
//       const { Compilation } = webpack;
  
//       // RawSource is one of the "sources" classes that should be used
//       // to represent asset sources in compilation.
//       const { RawSource } = webpack.sources;
  
//       // Tapping to the "thisCompilation" hook in order to further tap
//       // to the compilation process on an earlier stage.
//       compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
//         // Tapping to the assets processing pipeline on a specific stage.
//         compilation.hooks.processAssets.tap(
//           {
//             name: pluginName,
  
//             // Using one of the later asset processing stages to ensure
//             // that all assets were already added to the compilation by other plugins.
//             stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
//           },
//           (assets) => {
//             // "assets" is an object that contains all assets
//             // in the compilation, the keys of the object are pathnames of the assets
//             // and the values are file sources.
  
//             // Iterating over all the assets and
//             // generating content for our Markdown file.
//             const content =
//               '# In this build:\n\n' +
//               Object.keys(assets)
//                 .map((filename) => `- ${filename}`)
//                 .join('\n');
  
//             // Adding new asset to the compilation, so it would be automatically
//             // generated by the webpack in the output directory.
//             compilation.emitAsset(
//               this.options.outputFile,
//               new RawSource(content)
//             );
//           }
//         );
//       });
//     }
//   }
  
//   module.exports = { FileListPlugin };

const webpack = require("webpack");
const RuntimeGlobals = require("webpack/lib/RuntimeGlobals");
const RuntimeModule = require("webpack/lib/RuntimeModule");

// Similar to how lib/wasm-async/AsyncWasmLoadingRuntimeModule is implemented.
class XMLHttpRequestWasmLoadingRuntimeModule extends RuntimeModule {
  constructor(generateLoadBinaryCode) {
    super("wasm loading", RuntimeModule.STAGE_NORMAL);
    this.generateLoadBinaryCode = generateLoadBinaryCode;
  }

  generate() {
    const { compilation, chunk } = this;
    const { outputOptions, runtimeTemplate } = compilation;
    const fn = RuntimeGlobals.instantiateWasm;
    const wasmModuleSrcPath = compilation.getPath(
      JSON.stringify(outputOptions.webassemblyModuleFilename),
      {
        hash: `" + ${RuntimeGlobals.getFullHash}() + "`,
        hashWithLength: length =>
          `" + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + "`,
        module: {
          id: '" + wasmModuleId + "',
          hash: '" + wasmModuleHash + "',
          hashWithLength(length) {
            return `" + wasmModuleHash.slice(0, ${length}) + "`;
          }
        },
        runtime: chunk.runtime
      }
    );

    const loader = this.generateLoadBinaryCode(wasmModuleSrcPath);
    return `${fn} = ${runtimeTemplate.basicFunction(
      "exports, wasmModuleId, wasmModuleHash, importsObj",
      [
        `var req = ${loader};`,
        "return req",
        webpack.Template.indent([
          `.then(${runtimeTemplate.returningFunction(
            "WebAssembly.instantiate(bytes, importsObj)",
            "bytes"
          )})`,
          `.then(${runtimeTemplate.returningFunction(
            "Object.assign(exports, res.instance.exports)",
            "res"
          )});`,
        ]),
      ]
    )};`;
  }
}

// Similar to how lib/web/FetchCompileAsyncWasmPlugin is implemented.
class XMLHttpRequestWasmLoaderPlugin {
  type = "xml-http-request";

  apply(compiler) {
    const { webpack } = compiler;
    webpack.wasm.EnableWasmLoadingPlugin.setEnabled(compiler, this.type);

    compiler.hooks.thisCompilation.tap(
      "XMLHttpRequestWasmLoaderPlugin", compilation => {
        const { outputOptions, runtimeTemplate } = compilation;
        const globalWasmLoading = outputOptions.wasmLoading;
        const isEnabledForChunk = chunk => {
          const options = chunk.getEntryOptions();
          const wasmLoading =
            options && options.wasmLoading !== undefined
              ? options.wasmLoading
              : globalWasmLoading;
          return wasmLoading === this.type;
        };
        const generateLoadBinaryCode = path =>
          webpack.Template.asString([
            `new Promise(${runtimeTemplate.basicFunction(
              "resolve",
              [
                "const request = new XMLHttpRequest();",
                `request.onload = ${runtimeTemplate.returningFunction(
                  "resolve(request.response)", ""
                )};`,
                `request.open("GET", ${webpack.RuntimeGlobals.publicPath} + ${path});`,
                'request.responseType = "arraybuffer";',
                "request.send();",
              ]
            )})`
          ]);

        compilation.hooks.runtimeRequirementInTree
          .for(webpack.RuntimeGlobals.instantiateWasm)
          .tap("XMLHttpRequestWasmLoaderPlugin", (chunk, set, { chunkGraph }) => {
            if (!isEnabledForChunk(chunk)) return;
            if (
              !chunkGraph.hasModuleInGraph(
                chunk,
                m => m.type === "webassembly/async"
              )
            ) {
              return;
            }
            set.add(webpack.RuntimeGlobals.publicPath);
            compilation.addRuntimeModule(
              chunk,
              new XMLHttpRequestWasmLoadingRuntimeModule(generateLoadBinaryCode)
            );
          });
      }
    );
  }
}

module.exports = { XMLHttpRequestWasmLoaderPlugin };

// webpack.Template.indent([
//   "const request = new XMLHttpRequest();",
//   `request.onload = ${runtimeTemplate.returningFunction(
//     "resolve(request.response)", ""
//   )};`,
//   'request.open("GET", __webpack_require__.p + "opaque_ke.module.wasm");',
//   'request.responseType = "arraybuffer";',
//   "request.send();",
// ]),